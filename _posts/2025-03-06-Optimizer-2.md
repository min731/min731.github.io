---
title: "AdaDelta / Adamw / NAG / Nadam"
# author:
#   name: Joung min Lim
#   link: https://github.com/min731
date: 2025-03-06 00:00:00 +0900
# categories: [AI | 딥러닝, Architecture]
categories: [AI | 딥러닝, Concept]
# categories: [AI | 논문 리뷰, Attention is all you need]
# categories: [MLOps | 인프라 개발, Kserve]
# categories: [Life | 일상 이야기, 와플먹으면서 공부하기]
# categories: [STEM | 수학/통계, Statistics]
tags: [DeepLearning, AdaDelta, Adamw, NAG, Nadam]
description: "AdaDelta(Adaptive Delta), AdamW(Adam with Weight Decay), NAG(Nesterov Accelerated Gradient), NAdam(Nesterov-accelerated Adaptive Moment Estimation) Optimizer에 대해 알아봅시다."
image: assets/img/posts/resize/output/optimizer-2.png # 대표 이미지  가로 세로 비율 약 1.91:1 (예: 1200×628px)
math: true
toc: true
# pin: true
---

<div align="center">
  <small>Source: <a href="https://arxiv.org/abs/1609.04747">https://arxiv.org/abs/1609.04747</a></small>
</div>

> ## AdaDelta

### 1. AdaDelta Optimizer

Adadelta는 AdaGrad의 한계를 극복하기 위해 개발되었습니다. AdaGrad는 학습 과정에서 그래디언트의 제곱을 계속 누적하여 학습률을 조정했지만, 이로 인해 학습이 진행될수록 업데이트가 너무 작아지는 문제가 있었습니다. Adadelta는 이를 해결하기 위해 그래디언트의 이동 평균을 사용하고, 추가로 파라미터 업데이트의 이동 평균을 도입했습니다. 이를 통해 Adadelta는 학습률을 별도로 설정할 필요 없이 자동으로 조정하며, 학습 후반부에도 적절한 크기의 업데이트를 유지할 수 있게 되었습니다.

### 2. 동작 원리

#### 그래디언트 누적 제한
AdaGrad는 모든 과거 그래디언트를 누적했지만, Adadelta는 "지수 이동 평균"(Exponential Moving Average, EMA)을 사용하여 최근의 그래디언트에 더 큰 가중치를 둡니다.

$$
E[g^2]_t = ρ E[g^2]_{t-1} + (1-ρ)g_t^2
$$

여기서 $$\rho$$는 감쇠율로, 보통 0.95의 값을 사용합니다. 이 방식으로 오래된 그래디언트의 영향을 줄이고 최근 그래디언트에 더 많은 가중치를 줍니다.

#### 동적 학습률 조정
Adadelta는 명시적인 학습률을 사용하지 않습니다. 대신, 이전 파라미터 업데이트의 제곱 평균을 사용하여 현재 파라미터 업데이트를 조정합니다.

AdaDelta는 AdaGrad의 단점을 보완하기 위해 개발되었습니다. 과거의 모든 그래디언트를 누적하는 대신, 고정된 크기의 윈도우 내의 그래디언트만을 사용합니다. 또한, 학습률을 동적으로 조정합니다.

$$
\Delta \theta_t = - \frac{\sqrt{E[\Delta \theta^2]_{t-1} + \epsilon}}{\sqrt{E[g^2]_t + \epsilon}} \cdot g_t
$$

$$
(E[g^2]_t: 분모에\ 위치하여\ 큰\ 그래디언트를\ 가진\ 파라미터의\ 업데이트를\ 줄이는 효과)
$$

$$
(E[Δθ^2]_{t-1}: 분자에\ 위치하여\ 이전\ 업데이트의\ 크기에\ 비례하여\ 현재\ 업데이트를\ 조절하는\ 효과)
$$

여기서 $$E[\Delta \theta^2]_{t-1}$$는 이전 파라미터 업데이트의 제곱 평균입니다. 이 값도 EMA를 사용하여 계산됩니다:

$$
E[\Delta \theta^2]_{t} = \rho E[\Delta \theta^2]_{t-1} + (1-\rho)\Delta \theta_t^2
$$

### 3. 장점과 단점

#### 장점

- 학습률이 자동으로 조정되어 수동으로 설정할 필요가 없습니다.
- AdaGrad의 학습률 감소 문제를 해결합니다.

#### 단점

- 메모리 사용량이 AdaGrad보다 더 많습니다.
- 계산 복잡도가 약간 높습니다.
- 일부 경우에 수렴 속도가 느릴 수 있습니다.

> ## Adamw

### 1. Adamw Optimizer

AdamW는 Adam 최적화 알고리즘의 개선된 버전으로, 2017년에 제안되었습니다. Adam은 적응적 학습률과 모멘텀을 결합한 효과적인 알고리즘이었지만, L2 정규화(weight decay)를 제대로 처리하지 못하는 문제가 있었습니다. 이로 인해 일부 상황에서 일반화 성능이 저하되는 현상이 발생했습니다. AdamW는 이 문제를 해결하기 위해 weight decay를 loss function에서 분리하여 직접 적용하는 방식을 도입했습니다.

### 2. 동작 원리

AdamW의 동작 원리는 다음과 같은 수식으로 표현됩니다.

(1) 1차 모멘트 업데이트

$$
m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t
$$

$$
(g_t: 그래디언트)
$$

$$
(\beta_1: 모멘트\ 추정을\ 위한\ 감쇠율\ (일반적으로 \beta_1 = 0.9))
$$

$$
(m_t: 1차\ 모멘트\ 추정값)
$$

(2) 2차 모멘트(속도) 업데이트

$$
v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2
$$

$$
(\beta_2: 모멘트\ 추정을\ 위한\ 감쇠율\ (일반적으로 \beta_2 = 0.999))
$$

$$
(v_t: 2차\ 모멘트\ 추정값)
$$

(3) 편향 보정

$$
\hat{m}_t = \frac{m_t}{1 - \beta_1^t}
$$

$$
\hat{v}_t = \frac{v_t}{1 - \beta_2^t}
$$

(4) 파라미터 업데이트:

$$
\theta_t = \theta_{t-1} - \eta \frac{\hat{m}_t}{\sqrt{\hat{v}t} + \epsilon} - \eta \lambda \theta_{t-1}
$$

$$
(\theta_t: 시간\ t\ 에서의\ 파라미터)
$$

$$
(\eta: 학습률)
$$

$$
(\lambda: 가중치 감쇠 계수)
$$

$$
(epsilon: 0으로\ 나누는\ 것을\ 방지하기\ 위한\ 작은\ 상수\ (일반적으로 10^{-8}))
$$

### 3. 장점과 단점

#### 장점
- 효과적인 가중치 감쇠로 일반화 성능 향상
- 적응적 학습률을 통한 빠른 수렴
- 큰 모델과 데이터셋에서 뛰어난 성능
- 그래디언트 크기에 덜 민감한 안정적 학습
- Adam과 동일한 메모리 효율성

#### 단점
- SGD나 모멘텀 방식보다 약간 높은 계산 복잡도
- 가중치 감쇠 계수(λ) 선택을 위한 추가 튜닝 필요
- 학습 초기에 간혹 불안정할 수 있음
- 일부 간단한 문제에서는 SGD가 더 효과적일 수 있음
- 기본 SGD보다 복잡한 구현으로 디버깅이 어려울 수 있음

> ## NAG

### 1. NAG Optimizer

NAG Optimizer는 1983년 Yurii Nesterov가 제안한 최적화 알고리즘으로, 기존의 Momentum 방식을 개선한 것입니다. Momentum이 현재 위치의 그래디언트를 사용하는 반면, NAG는 모멘텀에 의해 이동할 것으로 예상되는 미래 위치의 그래디언트를 근사하여 사용합니다. 이 "미리 보기" 메커니즘을 통해 NAG는 더 정확한 방향으로 파라미터를 업데이트할 수 있게 되었습니다. NAG는 특히 볼록 최적화 문제에서 이론적으로 최적의 수렴 속도를 달성할 수 있음이 증명되어 주목받았으며, 딥러닝과 기계학습 분야에서 널리 사용되고 있습니다.

### 2. 동작 원리 (Momentum과 비교)

NAG Optimizer의 핵심 아이디어는 모멘텀에 의해 이동할 것으로 예상되는 위치에서의 그래디언트를 사용하는 것입니다. 이는 일반 Momentum과의 주요 차이점입니다. NAG와 Momentum의 동작 원리를 비교하여 설명하겠습니다.

#### Momentum의 동작 원리

(1) 속도 벡터 업데이트

$$
v_t = \mu v_{t-1} + \eta \nabla f(\theta_{t-1})
$$

(2) 파라미터 업데이트

$$
\theta_t = \theta_{t-1} - v_t
$$

#### NAG의 동작 원리

(1) 속도 벡터 업데이트

$$
v_t = \mu v_{t-1} + \eta \nabla f(\theta_{t-1} - \mu v_{t-1})
$$

$$
(v_t: 시간\ t에서의\ 속도\ 벡터)
$$

$$
(\mu: 모멘텀\ 계수\ (일반적으로\ 0.9))
$$

$$
(\eta: 학습률)
$$

$$
(\nabla f: 비용\ 함수의\ 그래디언트)
$$

$$
(\theta_t: 시간\ t에서의\ 모델\ 파라미터)
$$

(2) 파라미터 업데이트

$$
\theta_t = \theta_{t-1} - v_t
$$

$$
(v_t: 시간\ t에서의\ 속도\ 벡터)
$$

$$
(\theta_t: 시간\ t에서의\ 모델\ 파라미터)
$$

![](assets/img/posts/resize/output/nadam.png){: width="700px"}

<div align="center">
  <small>Source: <a href="https://arxiv.org/abs/1609.04747">https://arxiv.org/abs/1609.04747</a></small>
</div>

**파란색 벡터(Blue Vector)**

- 현재 위치에서 계산한 기울기(gradient)
- 일반적인 모멘텀 방식에서는 이 기울기를 보고 업데이트 방향을 결정

**갈색 벡터(Brown Vector)**

- 이전까지의 누적된 모멘텀 방향
- NAG에서는 이 방향으로 한 걸음 먼저 이동한 다음, 새로운 기울기를 측정
- 즉, "미리 가본 위치"

**빨간색 벡터(Red Vector)**

- 미리 이동한 위치에서 다시 측정한 새로운 기울기(gradient)
- 갈색 벡터로 이동한 후, 추가적으로 보정해야 하는 부분

**초록색 벡터(Green Vector)**

- 새로운 기울기를 반영하여 최종적으로 보정된 업데이트 방향
- 즉, NAG는 미리 이동한 후 새로운 기울기를 측정해서 더 정확한 방향으로 보정하는 방식

(1) Momentum Step : 과거의 움직임을 반영 **(갈색 벡터)**

$$
\mu v_{t-1}
$$

이는 이전 속도 벡터에 모멘텀 계수를 곱한 것으로, 파라미터가 모멘텀에 의해 이동할 것으로 예상되는 방향과 크기를 나타냅니다. NAG에서는 이 step을 먼저 적용하여 '미리 보기' 위치를 계산합니다.

(2) Gradient Step : 미래 예상 위치에서의 그래디언트를 반영 **(빨간색 벡터)**

$$
\eta \nabla f(\theta_{t-1} - \mu v_{t-1})
$$

이는 '미리 보기' 위치 $$(\theta_{t-1} - \mu v_{t-1})$$에서 계산된 그래디언트에 학습률을 곱한 것입니다. 이 step은 현재 파라미터 위치가 아닌, 모멘텀에 의해 이동할 것으로 예상되는 위치에서의 그래디언트를 사용합니다.

(3) Actual Step : Momentum Step과 Gradient Step을 결합한 최종 업데이트 벡터 **(초록색 벡터)**

$$
v_t = \mu v_{t-1} + \eta \nabla f(\theta_{t-1} - \mu v_{t-1})
$$

이는 실제로 파라미터를 업데이트하는 전체 step입니다. Momentum step과 Gradient step의 합으로 구성되며, 이 값을 현재 파라미터에서 빼서 새로운 파라미터 값을 얻습니다.

#### 주요 차이점(그래디언트 계산 위치)

Momentum: $$\nabla f(\theta_{t-1})$$ - 현재 파라미터 위치에서의 그래디언트
NAG: $$\nabla f(\theta_{t-1} - \mu v_{t-1})$$ - 모멘텀에 의한 예상 이동 후 위치에서의 그래디언트


#### "미리 보기" 메커니즘

NAG는 $$\theta_{t-1} - \mu v_{t-1}$$ 항을 통해 파라미터가 모멘텀에 의해 이동할 예상 위치를 계산합니다.
이 예상 위치에서의 그래디언트를 사용함으로써, NAG는 더 정확한 방향으로 파라미터를 업데이트할 수 있습니다.


#### 수렴 특성

Momentum: 빠른 수렴을 제공하지만, 때때로 목표를 지나칠 수 있습니다.
NAG: Momentum보다 더 나은 수렴 특성을 보이며, 특히 곡률이 큰 영역에서 더 효과적으로 감속합니다.


### 3. 장점과 단점

#### 장점
- 빠른 수렴: NAG는 "미리 보기" 메커니즘을 사용합니다. 현재 위치가 아닌 예상 이동 위치의 그래디언트를 계산하여 더 정확한 방향으로 이동합니다. 이로 인해 불필요한 지그재그 움직임이 줄어들어 빠르게 수렴합니다.
- 향상된 일반화: 미래 위치의 그래디언트를 사용함으로써 급격한 방향 전환을 줄입니다. 이는 과적합의 위험을 낮추고, 더 부드러운 최적화 경로를 따르게 하여 일반화 성능을 향상시킵니다.
- 이론적 보장: NAG의 수학적 구조는 볼록 함수에서 최적의 수렴 속도를 보장합니다. 이는 알고리즘의 동작이 수학적으로 잘 정의되어 있음을 의미합니다.
- 지역 최솟값 회피: 모멘텀 성분이 이전 업데이트의 관성을 유지하여, 작은 지역 최솟값을 넘어갈 수 있는 힘을 제공합니다. 이는 더 넓은 영역을 탐색하는 데 도움이 됩니다.
- 안정적인 수렴: 미래 위치의 그래디언트를 사용하여 현재 움직임을 조절하므로, 최적점 근처에서 과도한 진동을 방지합니다. 이는 보다 부드럽고 안정적인 수렴을 가능하게 합니다.

#### 단점
- 하이퍼파라미터 민감성: NAG의 성능은 학습률과 모멘텀 계수에 크게 의존합니다. 이 두 값의 상호작용이 복잡하여 최적값을 찾기 어려울 수 있습니다.
- 비적응성: NAG는 모든 파라미터에 대해 동일한 학습률을 사용합니다. 이는 각 파라미터의 특성이나 그래디언트의 크기를 고려하지 않아, 일부 상황에서 비효율적일 수 있습니다.
- 비볼록 문제에서의 한계: NAG의 이론적 보장은 주로 볼록 함수에 대해 성립합니다. 비볼록 문제에서는 수학적 보장이 약해지며, 복잡한 손실 함수 지형에서 예측하기 어려운 동작을 보일 수 있습니다.
- 계산 복잡성: NAG는 미래 위치의 그래디언트를 계산해야 하므로, 기본 경사 하강법보다 약간 더 많은 연산이 필요합니다. 이는 대규모 모델에서 계산 시간을 증가시킬 수 있습니다.
- 메모리 요구: NAG는 현재 파라미터 값 외에도 속도 벡터를 저장해야 합니다. 이는 모델의 파라미터 수에 비례하여 추가 메모리를 필요로 합니다.

> ## Nadam

### 1. Nadam Optimizer

NAdam(Nesterov-accelerated Adaptive Moment Estimation) Optimizer는 2016년 Timothy Dozat가 제안한 최적화 알고리즘입니다. 이는 Adam(Adaptive Moment Estimation)과 NAG(Nesterov Accelerated Gradient)의 장점을 결합한 것입니다. Adam이 적응적 학습률과 모멘텀을 사용하는 반면, NAdam은 여기에 Nesterov의 "미리 보기" 메커니즘을 추가했습니다. 이를 통해 NAdam은 Adam의 적응성과 NAG의 향상된 수렴 특성을 모두 갖추게 되었습니다. Adam이 딥러닝 분야에서 널리 사용되는 가운데, NAdam은 더 빠른 수렴과 향상된 일반화 성능을 제공하여 주목받고 있습니다.

### 2. 동작 원리(Adam과 비교)

NAdam의 핵심 아이디어는 Adam의 적응적 학습률 조정 메커니즘에 Nesterov의 모멘텀 개념을 통합한 것입니다. Adam과 NAdam의 동작 원리를 단계별로 비교하여 설명하겠습니다.

#### Adam의 동작 원리

(1) 1차, 2차 모멘트 업데이트

$$
m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t
$$

$$
v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2
$$

(2) 편향 보정

$$
\hat{m}_t = \frac{m_t}{1 - \beta_1^t}
$$

$$
\hat{v}_t = \frac{v_t}{1 - \beta_2^t}
$$

(3) 파라미터 업데이트

$$
\theta_t = \theta_{t-1} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t
$$


#### NAdam의 동작 원리

(1) 1차, 2차 모멘트 업데이트 (Adam과 동일)

$$
m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t
$$

$$
v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2
$$

(2) 편향 보정 (Adam과 동일)

$$
\hat{m}_t = \frac{m_t}{1 - \beta_1^t}
$$

$$
\hat{v}_t = \frac{v_t}{1 - \beta_2^t}
$$

(3) Nesterov 모멘텀 적용 및 파라미터 업데이트

$$
\theta_t = \theta_{t-1} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon}(\beta_1 \hat{m}_t + (1 - \beta_1) g_t)
$$

$$
(\theta_t: 시간\ t에서의\ 파라미터\ 값)
$$

$$
(m_t: 그래디언트의\ 1차\ 모멘트\ (평균)\ 추정값)
$$

$$
(v_t: 그래디언트의\ 2차\ 모멘트\ (제곱의\ 평균)\ 추정값)
$$

$$
(\hat{m}_t: 편향이\ 보정된\ 1차\ 모멘트\ 추정값)
$$

$$
(\hat{v}_t: 편향이\ 보정된\ 2차\ 모멘트\ 추정값)
$$

$$
(\beta_1: 1차\ 모멘트\ 추정값의\ 감쇠율\ (일반적으로\ 0.9))
$$

$$
(\beta_2: 2차\ 모멘트\ 추정값의\ 감쇠율\ (일반적으로\ 0.999))
$$

$$
(\eta: 학습률)
$$

$$
(g_t: 시간\ t에서의\ 손실\ 함수의\ 그래디언트)
$$

$$
(\epsilon: 0으로\ 나누는\ 것을\ 방지하기\ 위한\ 작은\ 상수\ (일반적으로\ 10^{-8}))
$$

$$
(t: 현재까지의\ 업데이트\ 횟수)
$$

#### 주요 차이점

(1) 모멘텀 적용

**Adam vs NAdam**

- Adam: 편향 보정된 1차 모멘트 $$\hat{m}_t$$만 사용합니다.
- NAdam: Nesterov 모멘텀 개념을 도입하여 $$(\beta_1 \hat{m}_t + (1 - \beta_1) g_t)$$를 사용합니다.


**NAG vs NAdam**

- NAG: 미분을 계산하기 전에 momentum을 적용합니다.즉, 파라미터를 업데이트하기 전에 momentum을 한 번 적용하고, 그 후에 그래디언트를 계산합니다. 수식으로 표현하면 $$g_t = \nabla f(\theta_{t-1} - \mu v_{t-1})$$이고 이전의 momentum을 의미하며, 이를 바탕으로 그래디언트를 계산합니다.

- NAdam: NAG와 Adam을 결합한 형태입니다.NAdam은 미분 후, 파라미터 업데이트 단계에서 momentum 효과를 적용합니다. 즉, 일반적인 그래디언트를 계산한 후, 그 결과에 momentum을 추가하여 업데이트를 진행합니다. 수식으로는 $$g_t = \nabla f(\theta_{t-1})$$ 입니다. 이 후, Adam 방식으로 momentum과 RMSprop의 효과를 결합하여 파라미터를 업데이트합니다.

(2) 그래디언트 계산

- Adam: 현재 파라미터 위치에서의 그래디언트만 사용합니다.
- NAdam: 현재 위치의 그래디언트와 모멘텀에 의해 예상되는 미래 위치의 그래디언트를 함께 고려합니다.
NAdam의 "미리 보기" 메커니즘은 파라미터 공간에서 더 효율적인 경로를 찾는 데 도움을 줍니다.
이는 특히 급격한 곡률 변화가 있는 손실 함수 지형에서 유용할 수 있습니다.

### 3. 장점과 단점

#### 장점
- 빠른 수렴: Nesterov 모멘텀과 Adam의 적응적 학습률을 결합하여, 더 정확한 그래디언트 방향을 예측합니다.
- 향상된 일반화: "미리 보기" 메커니즘으로 과도한 진동을 줄이고, 더 부드러운 최적화 경로를 따릅니다.
- 적응적 학습률: Adam처럼 파라미터별 학습률을 조정하여 다양한 스케일의 그래디언트를 효과적으로 처리합니다.
- 희소 그래디언트 처리: 적응적 학습률로 인해 자주 업데이트되지 않는 파라미터도 효과적으로 학습합니다.
- 하이퍼파라미터 강건성: 적응적 특성으로 인해 초기 학습률 설정에 덜 민감합니다.

#### 단점

- 계산 복잡성: Nesterov 모멘텀 계산으로 인해 Adam보다 약간의 추가 연산이 필요합니다.
- 메모리 요구: 1차 및 2차 모멘트 추정치를 저장해야 하므로 추가 메모리가 필요합니다.
- 이론적 이해의 한계: Adam과 NAG의 복잡한 결합으로 인해 수학적 분석이 어려울 수 있습니다.
- 일부 상황에서의 성능 저하: 모든 문제에 최적화되어 있지 않아, 단순한 문제에서는 오히려 성능이 떨어질 수 있습니다.
- 학습 초기의 불안정성: 초기 단계에서 모멘텀과 적응적 학습률의 상호작용으로 불안정할 수 있습니다.